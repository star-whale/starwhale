/*
 * Copyright 2022 Starwhale, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ai.starwhale.mlops.backup.db;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Builder
@AllArgsConstructor
public class MysqlBackupService {
    String url;
    String username;
    String password;
    String driver;

    static final String SQL_START_PATTERN = "-- start";
    static final String SQL_END_PATTERN = "-- end";

    private static Connection doConnect(String driver, String url, String username, String password)
            throws SQLException, ClassNotFoundException {
        Class.forName(driver);
        Connection connection = DriverManager.getConnection(url, username, password);
        log.debug("DB Connect Successfully");
        return connection;
    }

    public static String extractDatabaseFromUrl(String url) {
        if (!hasDatabase(url)) {
            throw new RuntimeException("Invalid JDBC URL supplied: " + url);
        }
        return url.substring(url.lastIndexOf("/") + 1, url.indexOf("?"));
    }

    public static boolean hasDatabase(String url) {
        if (url == null || url.isEmpty()) {
            return false;
        }
        int index = url.indexOf("://");
        if (index == -1) {
            return false;
        }
        index = url.indexOf("/", index + 3);
        return index != -1;
    }

    private static TablesResponse getAllTablesAndViews(Statement statement, String database) throws SQLException {
        List<String> tables = new ArrayList<>();
        List<String> views = new ArrayList<>();

        ResultSet rs;
        rs = statement.executeQuery("SHOW TABLE STATUS FROM `" + database + "`;");
        while (rs.next()) {
            String comment = rs.getString("Comment");
            if ("VIEW".equals(comment)) {
                views.add(rs.getString("Name").trim());
            } else {
                tables.add(rs.getString("Name").trim());
            }
        }

        return new TablesResponse(tables, views);
    }

    public String backup(Set<String> ignores) throws SQLException, ClassNotFoundException {
        var database = extractDatabaseFromUrl(this.url);

        try (var connection = doConnect(this.driver, this.url, this.username, this.password);
                var statement = connection.createStatement(
                        ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
            StringBuilder sql = new StringBuilder();
            sql.append("--");
            sql.append("\n-- Generated by Starwhale");
            sql.append("\n-- Date: ").append(new SimpleDateFormat("d-M-y H:m:s").format(new Date()));
            sql.append("\n--");

            sql.append("\n\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;")
                    .append("\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;")
                    .append("\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;")
                    .append("\n/*!50503 SET NAMES utf8mb4 */;")
                    .append("\n/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;")
                    .append("\n/*!40103 SET TIME_ZONE='+00:00' */;")
                    .append("\n/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;")
                    .append("\n/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;")
                    .append("\n/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;")
                    .append("\n/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;\n\n");

            sql.append("\n\nCREATE DATABASE /*!32312 IF NOT EXISTS*/ `").append(database).append("` ")
                .append("/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ ")
                .append("/*!80016 DEFAULT ENCRYPTION='N' */;");

            sql.append("\n\nUSE `").append(database).append("`;\n\n");

            // get the tables that are in the database
            TablesResponse allTablesAndViews = getAllTablesAndViews(statement, database);

            List<String> tables = allTablesAndViews.getTables().stream()
                    .filter(t -> !ignores.contains(t))
                    .collect(Collectors.toList());

            for (String table : tables) {
                try {
                    sql.append(getTableCreateStatement(statement, table));
                    sql.append(getDataInsertStatement(statement, table));
                } catch (SQLException e) {
                    log.error("Exception occurred while processing table: " + table, e);
                }
            }

            List<String> views = allTablesAndViews.getViews().stream()
                    .filter(t -> !ignores.contains(t))
                    .collect(Collectors.toList());
            for (String view : views) {
                try {
                    sql.append(getCreateViewStatement(statement, view));
                } catch (SQLException e) {
                    log.error("Exception occurred while processing view: " + view, e);
                }
            }

            sql.append("\n/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;")
                    .append("\n/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;")
                    .append("\n/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;")
                    .append("\n/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;")
                    .append("\n/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;")
                    .append("\n/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;")
                    .append("\n/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;")
                    .append("\n/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;");

            sql.append("\n-- Dump completed on").append(new SimpleDateFormat("d-M-y H:m:s").format(new Date()));

            return sql.toString();
        }
    }

    private String getTableCreateStatement(Statement statement, String table) throws SQLException {
        StringBuilder sql = new StringBuilder();
        ResultSet rs;

        if (table != null && !table.isEmpty()) {
            rs = statement.executeQuery("SHOW CREATE TABLE " + "`" + table + "`;");
            while (rs.next()) {
                String tableName = rs.getString(1);
                String query = rs.getString(2);
                sql.append("\n\n--");
                sql.append("\n").append(SQL_START_PATTERN).append("  table dump : ").append(tableName);
                sql.append("\n--\n\n");
                sql.append("\nDROP TABLE IF EXISTS `").append(tableName).append("`;\n\n");
                sql.append("\n\n--");
                sql.append("\n").append(SQL_END_PATTERN).append("  table dump : ").append(tableName);
                sql.append("\n--\n\n");

                sql.append("\n\n--");
                sql.append("\n").append(SQL_START_PATTERN).append("  table dump : ").append(tableName);
                sql.append("\n--\n\n");
                sql.append(query).append(";\n\n");
                sql.append("\n\n--");
                sql.append("\n").append(SQL_END_PATTERN).append("  table dump : ").append(tableName);
                sql.append("\n--\n\n");
            }
        }

        return sql.toString();
    }

    private String getCreateViewStatement(Statement statement, String view) throws SQLException {
        StringBuilder sql = new StringBuilder();
        ResultSet rs;

        if (view != null && !view.isEmpty()) {
            rs = statement.executeQuery("SHOW CREATE VIEW " + "`" + view + "`;");
            while (rs.next()) {
                String viewName = rs.getString(1);
                String viewQuery = rs.getString(2);
                sql.append("\n\n--");
                sql.append("\n").append(SQL_START_PATTERN).append("  view dump : ").append(viewName);
                sql.append("\n--\n\n");

                String finalQuery = "CREATE OR REPLACE VIEW `"
                        + viewName
                        + "` " + (viewQuery.substring(viewQuery.indexOf("AS")).trim());
                sql.append(finalQuery).append(";");

                sql.append("\n\n--");
                sql.append("\n").append(SQL_END_PATTERN).append("  view dump : ").append(viewName);
                sql.append("\n--\n\n");
            }
        }

        return sql.toString();
    }

    private String getDataInsertStatement(Statement statement, String table) throws SQLException {

        StringBuilder sql = new StringBuilder();

        ResultSet rs = statement.executeQuery("SELECT * FROM " + "`" + table + "`;");

        rs.last();
        int rowCount = rs.getRow();

        if (rowCount <= 0) {
            return sql.toString();
        }

        sql.append("\n--").append("\n-- Inserts of ").append(table).append("\n--\n\n");

        sql.append("\n LOCK TABLES `").append(table).append("` WRITE;\n");
        sql.append("\n/*!40000 ALTER TABLE `").append(table).append("` DISABLE KEYS */;\n");

        sql.append("\n--\n")
                .append(SQL_START_PATTERN).append(" table insert : ").append(table)
                .append("\n--\n");

        sql.append("INSERT INTO `").append(table).append("`(");

        ResultSetMetaData metaData = rs.getMetaData();
        int columnCount = metaData.getColumnCount();

        for (int i = 0; i < columnCount; i++) {
            sql.append("`")
                    .append(metaData.getColumnName(i + 1))
                    .append("`, ");
        }

        sql.deleteCharAt(sql.length() - 1).deleteCharAt(sql.length() - 1).append(") VALUES \n");

        rs.beforeFirst();
        while (rs.next()) {
            sql.append("(");
            for (int i = 0; i < columnCount; i++) {

                int columnType = metaData.getColumnType(i + 1);
                int columnIndex = i + 1;

                if (Objects.isNull(rs.getObject(columnIndex))) {
                    sql.append(rs.getObject(columnIndex)).append(", ");
                } else if (columnType == Types.INTEGER || columnType == Types.TINYINT || columnType == Types.BIT) {
                    sql.append(rs.getInt(columnIndex)).append(", ");
                } else {
                    String val = rs.getString(columnIndex);
                    val = val.replace("'", "\\'");

                    sql.append("'").append(val).append("', ");
                }
            }

            sql.deleteCharAt(sql.length() - 1).deleteCharAt(sql.length() - 1);

            if (rs.isLast()) {
                sql.append(")");
            } else {
                sql.append("),\n");
            }
        }

        sql.append(";");

        sql.append("\n--\n")
                .append(SQL_END_PATTERN).append(" table insert : ").append(table)
                .append("\n--\n");

        sql.append("\n/*!40000 ALTER TABLE `").append(table).append("` ENABLE KEYS */;");
        sql.append("\nUNLOCK TABLES;");

        return sql.toString();
    }

    public boolean restore(String sql) throws SQLException, ClassNotFoundException {
        try (var connection = doConnect(this.driver, this.url, this.username, this.password);
                var statement = connection.createStatement(
                        ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {

            //disable foreign key check
            statement.addBatch("SET FOREIGN_KEY_CHECKS = 0");
            while (sql.contains(SQL_START_PATTERN)) {
                int startIndex = sql.indexOf(SQL_START_PATTERN);
                int endIndex = sql.indexOf(SQL_END_PATTERN);
                String executable = sql.substring(startIndex, endIndex).trim();
                log.debug("adding executable SQL chunk to batch:{}", executable);
                statement.addBatch(executable);
                sql = sql.substring(endIndex + 1);
            }
            statement.addBatch("SET FOREIGN_KEY_CHECKS = 1");
            long[] results = statement.executeLargeBatch();
            log.debug("{} queries were executed in batches for provided SQL String with the following results:{}",
                    results.length, Arrays.toString(results));
            return true;
        }
    }
}
